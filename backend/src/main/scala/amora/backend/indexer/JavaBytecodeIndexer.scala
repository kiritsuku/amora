package amora.backend.indexer

import java.io.ByteArrayOutputStream
import java.io.PrintWriter
import java.net.URI

import scala.util.Failure
import scala.util.Success
import scala.util.Try

import amora.backend.Logger
import javax.tools.FileObject
import javax.tools.JavaFileManager
import javax.tools.JavaFileObject
import javax.tools.SimpleJavaFileObject
import javax.tools.StandardJavaFileManager
import javax.tools.ToolProvider
import amora.converter.ClassfileConverter
import amora.converter.protocol.Hierarchy

/**
 * Provides functionality to extract information out of Java bytecode.
 */
final class JavaBytecodeIndexer(logger: Logger) {

  /**
   * Converts pairs of file names and Java sources to pairs of file names and
   * hierarchies.
   */
  def bytecodeToHierarchy(data: Seq[(String, String)]): Try[Seq[(String, Seq[Hierarchy])]] = Try {
    val c = ToolProvider.getSystemJavaCompiler
    val vfm = new VirtualJavaFileManager(c.getStandardFileManager(null, null, null))

    data flatMap {
      case (filename, src) ⇒
        require(filename.endsWith(".java"), "Only Java files are currently supported")
        val s = new ByteArrayOutputStream
        val pw = new PrintWriter(s)

        c.getTask(
            pw, vfm, null,
            /* options */ java.util.Arrays.asList("-parameters"),
            null,
            /* compilationUnits */ java.util.Arrays.asList(new VirtualJavaFile(filename, src))
        ).call()

        val errorMsgs = new String(s.toByteArray(), "UTF-8")
        if (errorMsgs.nonEmpty)
          throw new IllegalStateException(s"Errors occurred during compilation of file `$filename`:\n$errorMsgs")

        vfm.buffers.map {
          case (_, bytecode) ⇒
            new ClassfileConverter().convert(bytecode) match {
              case Success(res) ⇒
                filename → res
              case Failure(f) ⇒
                throw f
            }
        }
    }
  }

  /**
   * Represents an in memory Java file by its name and its source code.
   */
  private final class VirtualJavaFile(name: String, code: String)
      extends SimpleJavaFileObject(URI.create(s"string:///$name"), JavaFileObject.Kind.SOURCE) {
    override def getCharContent(ignoreEncodingErrors: Boolean): CharSequence = code
  }

  /**
   * Wraps a `StandardJavaFileManager` in order to allow us to access the
   * bytecode that is generated by the Java compiler.
   */
  private final class VirtualJavaFileManager(underlying: StandardJavaFileManager) extends JavaFileManager {
    import javax.tools.JavaFileManager._
    import javax.tools.JavaFileObject._

    private var bs = Map[String, ByteArrayOutputStream]()

    def buffers = bs.map { case (k, v) ⇒ k → v.toByteArray() }.toList

    override def getJavaFileForOutput(location: Location, className: String, kind: Kind, sibling: FileObject): JavaFileObject = {
      new SimpleJavaFileObject(URI.create(className), kind) {
        override def openOutputStream = {
          val s = new ByteArrayOutputStream
          bs += className → s
          s
        }
      }
    }

    // the following methods forward to the default implementation
    override def getJavaFileForInput(location: Location, className: String, kind: Kind): JavaFileObject = underlying.getJavaFileForInput(location, className, kind)
    override def getClassLoader(location: Location): ClassLoader = underlying.getClassLoader(location)
    override def close(): Unit = underlying.close()
    override def flush(): Unit = underlying.flush()
    override def getFileForInput(x$1: Location, x$2: String, x$3: String): FileObject = underlying.getFileForInput(x$1, x$2, x$3)
    override def getFileForOutput(x$1: Location, x$2: String, x$3: String, x$4: FileObject): FileObject = underlying.getFileForOutput(x$1, x$2, x$3, x$4)
    override def handleOption(current: String, remaining: java.util.Iterator[String]): Boolean = underlying.handleOption(current, remaining)
    override def hasLocation(x$1: Location): Boolean = underlying.hasLocation(x$1)
    override def inferBinaryName(x$1: Location, x$2: JavaFileObject): String = underlying.inferBinaryName(x$1, x$2)
    override def isSameFile(a: FileObject, b: FileObject): Boolean = underlying.isSameFile(a, b)
    override def isSupportedOption(option: String): Int = underlying.isSupportedOption(option)
    override def list(x$1: Location, x$2: String, x$3: java.util.Set[Kind], x$4: Boolean): java.lang.Iterable[JavaFileObject] = underlying.list(x$1, x$2, x$3, x$4)
  }
}
